<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Pac-Man+</title>

  <!-- ✅ Absolute link to your shared CSS -->
  <link rel="stylesheet" href="https://thereelsho.github.io/10in1arcade/arcade.css"> 

  <style>
    body { background:#000; color:#fff; text-align:center; font-family:Arial; margin:0; padding:10px }
    canvas { background:#111; display:block; margin:10px auto; border:2px solid #555 }
    .hud { margin:6px 0 }
  </style>
</head>
<body>
  <h1>Pac-Man+</h1>
  <div class="hud">
    Score: <span id="score">0</span> · 
    High: <span id="high">0</span> · 
    Lives: <span id="lives">3</span>
  </div>
  <canvas id="game" width="672" height="744"></canvas>
  <a href="../index.html" class="back-btn">⟵ Back to Arcade</a>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const tileSize = 24;
    let score = 0, lives = 3, highScore = parseInt(localStorage.pacmanHigh || "0");
    document.getElementById("high").textContent = highScore;

    // Map: 1=wall, 0=pellet, 3=power pellet, 2=empty
    const map = [
      "1111111111111111111111111",
      "1030000000110000000000301",
      "1011111110110111111111011",
      "1011111110110111111111011",
      "1000000000000000000000001",
      "1011110111111111011111011",
      "1000000100001000100000001",
      "1111110101111010111111111",
      "0000010000000000000001000",
      "1111110110111111011011111",
      "1000000000110000000000001",
      "1011111110110111111111011",
      "1030000000000000000000301",
      "1111111111111111111111111",
    ].map(r => r.split("").map(Number));

    const pacman = { x:1,y:1,dx:0,dy:0,nextDir:null,speed:0.1,mouth:0,open:true };

    const ghosts = [
      { x:12,y:7,dx:0,dy:-1,color:"red",edible:false },
      { x:13,y:7,dx:0,dy:1,color:"pink",edible:false },
      { x:11,y:7,dx:1,dy:0,color:"cyan",edible:false },
      { x:12,y:8,dx:-1,dy:0,color:"orange",edible:false }
    ];

    document.addEventListener("keydown", e => {
      if(e.key==="ArrowUp") pacman.nextDir={dx:0,dy:-1};
      if(e.key==="ArrowDown") pacman.nextDir={dx:0,dy:1};
      if(e.key==="ArrowLeft") pacman.nextDir={dx:-1,dy:0};
      if(e.key==="ArrowRight") pacman.nextDir={dx:1,dy:0};
    });

    function isWall(x,y){ return map[y] && map[y][x]===1; }

    function updatePacman(){
      if(Number.isInteger(pacman.x)&&Number.isInteger(pacman.y)&&pacman.nextDir){
        const nx=pacman.x+pacman.nextDir.dx, ny=pacman.y+pacman.nextDir.dy;
        if(!isWall(nx,ny)){ pacman.dx=pacman.nextDir.dx; pacman.dy=pacman.nextDir.dy; pacman.nextDir=null; }
      }
      const nx=pacman.x+pacman.dx*pacman.speed, ny=pacman.y+pacman.dy*pacman.speed;
      if(!isWall(Math.round(nx),Math.round(ny))){ pacman.x=nx; pacman.y=ny; }
      else{ pacman.dx=0; pacman.dy=0; }

      const gx=Math.round(pacman.x), gy=Math.round(pacman.y);
      if(map[gy]&&map[gy][gx]===0){ map[gy][gx]=2; score+=10; }
      else if(map[gy]&&map[gy][gx]===3){ map[gy][gx]=2; score+=50; ghosts.forEach(g=>g.edible=true); setTimeout(()=>ghosts.forEach(g=>g.edible=false),6000);}
      document.getElementById("score").textContent=score;

      // Animate mouth
      if(pacman.open){ pacman.mouth+=0.05; if(pacman.mouth>=0.25) pacman.open=false; }
      else{ pacman.mouth-=0.05; if(pacman.mouth<=0) pacman.open=true; }
    }

    function updateGhost(g){
      if(Number.isInteger(g.x)&&Number.isInteger(g.y)){
        const choices=[]; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=Math.round(g.x)+dx, ny=Math.round(g.y)+dy;
          if(!isWall(nx,ny)) choices.push({dx,dy});
        });
        if(choices.length){
          choices.sort((a,b)=>{
            const da=Math.abs((g.x+a.dx)-pacman.x)+Math.abs((g.y+a.dy)-pacman.y);
            const db=Math.abs((g.x+b.dx)-pacman.x)+Math.abs((g.y+b.dy)-pacman.y);
            return da-db;
          });
          g.dx=choices[0].dx; g.dy=choices[0].dy;
        }
      }
      const nx=g.x+g.dx*0.08, ny=g.y+g.dy*0.08;
      if(!isWall(Math.round(nx),Math.round(ny))){ g.x=nx; g.y=ny; }
    }

    function checkCollisions(){
      ghosts.forEach(g=>{
        if(Math.abs(g.x-pacman.x)<0.5&&Math.abs(g.y-pacman.y)<0.5){
          if(g.edible){ score+=200; g.x=12; g.y=7; g.dx=0; g.dy=1; g.edible=false; }
          else{
            lives--; document.getElementById("lives").textContent=lives;
            if(lives<=0){
              if(score>highScore){ localStorage.pacmanHigh=score; highScore=score; }
              alert("Game Over! Final score: "+score+" · High: "+highScore);
              location.reload();
            }
            pacman.x=1; pacman.y=1; pacman.dx=0; pacman.dy=0;
          }
        }
      });
      document.getElementById("high").textContent=Math.max(highScore,score);
    }

    function drawMap(){
      for(let y=0;y<map.length;y++){
        for(let x=0;x<map[y].length;x++){
          if(map[y][x]===1){ ctx.fillStyle="#1a1aff"; ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize); }
          else if(map[y][x]===0){ ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(x*tileSize+tileSize/2,y*tileSize+tileSize/2,3,0,Math.PI*2); ctx.fill(); }
          else if(map[y][x]===3){ ctx.fillStyle="#ff0"; ctx.beginPath(); ctx.arc(x*tileSize+tileSize/2,y*tileSize+tileSize/2,6,0,Math.PI*2); ctx.fill(); }
        }
      }
    }

    function drawPacman(){
      ctx.fillStyle="yellow";
      ctx.beginPath();
      const angle=Math.atan2(pacman.dy,pacman.dx)||0;
      ctx.arc(pacman.x*tileSize+tileSize/2,pacman.y*tileSize+tileSize/2,tileSize/2-2,
              angle+pacman.mouth, angle+2*Math.PI-pacman.mouth);
      ctx.lineTo(pacman.x*tileSize+tileSize/2,pacman.y*tileSize+tileSize/2);
      ctx.fill();
    }

    function drawGhost(g){
      const px=g.x*tileSize+tileSize/2, py=g.y*tileSize+tileSize/2;
      ctx.fillStyle=g.edible?"blue":g.color;
      ctx.beginPath();
      ctx.arc(px,py,tileSize/2-2,Math.PI,0);
      ctx.lineTo(px+tileSize/2-2,py+tileSize/2-2);
      ctx.lineTo(px-tileSize/2+2,py+tileSize/2-2);
      ctx.closePath(); ctx.fill();

      // Eyes
      const eyeDx = pacman.x-g.x, eyeDy = pacman.y-g.y;
      const len=Math.hypot(eyeDx,eyeDy)||1;
      const ex= (eyeDx/len)*3, ey=(eyeDy/len)*3;
      ctx.fillStyle="#fff";
      ctx.beginPath(); ctx.arc(px-5,py,5,0,Math.PI*2); ctx.arc(px+5,py,5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#000";
      ctx.beginPath(); ctx.arc(px-5+ex,py+ey,2,0,Math.PI*2); ctx.arc(px+5+ex,py+ey,2,0,Math.PI*2); ctx.fill();
    }

    function loop(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawMap(); updatePacman();
      ghosts.forEach(g=>{ updateGhost(g); drawGhost(g); });
      drawPacman(); checkCollisions();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
