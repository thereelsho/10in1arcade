<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Pac-Man+</title>

  <!-- ✅ Absolute link to your shared CSS -->
  <link rel="stylesheet" href="https://thereelsho.github.io/10in1arcade/arcade.css">

  <style>
    body { background:#000; color:#fff; text-align:center; font-family:Arial; margin:0; padding:10px }
    canvas { background:#111; display:block; margin:10px auto; border:2px solid #555; image-rendering: pixelated; }
    .hud { margin:6px 0; font-family: 'Press Start 2P', system-ui, Arial, sans-serif; font-size: 12px; }
    .overlay {
      position: absolute; left:0; right:0; margin:auto; width:100%; text-align:center;
      pointer-events:none; font-family:'Press Start 2P', system-ui, Arial, sans-serif;
    }
    .overlay .msg {
      display:inline-block; padding:8px 14px; border:2px solid #ff2d75; border-radius:8px;
      color:#ff2d75; text-shadow:0 0 6px #ff2d75; background:#000a; margin-top:8px;
    }
    .stage { position: relative; width: fit-content; margin: 0 auto; }
  </style>
</head>
<body>
  <h1>Pac-Man+</h1>
  <div class="hud">
    Score: <span id="score">0</span> ·
    High: <span id="high">0</span> ·
    Lives: <span id="lives">3</span>
  </div>

  <div class="stage">
    <canvas id="game" width="672" height="744"></canvas>
    <div class="overlay" id="overlay"><span class="msg" id="overlayText">READY!</span></div>
  </div>

  <a href="../index.html" class="back-btn">⟵ Back to Arcade</a>

  <script>
  // ======= CONFIG =======
  const tile = 24;                 // tile size
  const speedPac = 0.11;           // pac speed per frame (tiles)
  const speedGhost = 0.10;         // ghost speed per frame
  const speedFright = 0.08;
  const frightDuration = 6000;     // ms frightened
  const scatterDur = 7000;         // ms
  const chaseDur   = 20000;        // ms
  const pelletScore = 10;
  const powerScore  = 50;
  const eatGhostScore = 200;

  // ======= SOUNDS (optional; comment out if you don't have files yet) =======
  const S = {
    waka:    tryAudio("https://thereelsho.github.io/10in1arcade/sounds/waka.wav", 0.35),
    power:   tryAudio("https://thereelsho.github.io/10in1arcade/sounds/power.wav", 0.45),
    eat:     tryAudio("https://thereelsho.github.io/10in1arcade/sounds/eatghost.wav", 0.5),
    death:   tryAudio("https://thereelsho.github.io/10in1arcade/sounds/death.wav", 0.6),
  };
  function tryAudio(url, vol=0.5){
    const a = new Audio(); a.src = url; a.preload = "auto"; a.volume = vol; return a;
  }
  function play(a){ if(!a) return; try{ a.currentTime=0; a.play(); }catch(e){} }

  // ======= CANVAS & HUD =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const livesEl = document.getElementById('lives');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlayText');

// ======= MAP =======
// 0=pellet, 1=wall, 2=empty, 3=power pellet, 5=gate
const raw = [
  "1111111111111111111111111111",
  "1000000000111111000000000001",
  "1011110111111111111011111101",
  "1031110111111111111011111301",
  "1011110111111111111011111101",
  "1000000000001111000000000001",
  "1011110111111111111011111101",
  "1000000111000000001110000001",
  "1111110111011111101110111111",
  "2222220111001111001110222222",
  "1111110111115111111110111111",
  "1000000000005000000000000001",
  "1111110111115111111110111111",
  "2222220111000000001110222222",
  "1111110111011111101110111111",
  "1000000111001111001110000001",
  "1011110111111111111011111101",
  "1031110111111111111011111301",
  "1011110111111111111011111101",
  "1000000000111111000000000001",
  "1111111111111111111111111111"
].map(r=>r.split("").map(ch => {
  if(ch==="2") return 2;
  if(ch==="5") return 5;
  return +ch;
}));

  const ROWS = raw.length, COLS = raw[0].length;
  canvas.width = COLS * tile;
  canvas.height = ROWS * tile;

  // ======= STATE =======
  let score = 0;
  let high = parseInt(localStorage.pacmanHigh || '0');
  highEl.textContent = high;
  let lives = 3;
  let mode = 'ready';  // 'ready' | 'play' | 'fright' | 'dying' | 'levelup' | 'gameover'
  let level = 1;

  // Pac-Man
  const pac = {
    x: 14, y: 23, dx: 0, dy: 0, nextDir: null,
    speed: speedPac, mouth: 0, open: true
  };

  // Scatter targets (corners)
  const corners = {
    blinky: {x: COLS-3, y: 1},
    pinky:  {x: 2, y: 1},
    inky:   {x: COLS-3, y: ROWS-2},
    clyde:  {x: 2, y: ROWS-2},
  };

  // Ghosts
  function makeGhost(name, x,y, color){
    return { name, x, y, dx:0, dy:0, color, edible:false, eyes:false, speed:speedGhost, scatterTarget: corners[name] };
  }
  let ghosts = [
    makeGhost('blinky', 14, 11, 'red'),
    makeGhost('pinky',  13, 14, 'pink'),
    makeGhost('inky',   14, 14, 'cyan'),
    makeGhost('clyde',  15, 14, 'orange'),
  ];

  // Mode timer for scatter/chase cycling
  let modeTimer = 0;
  let inScatter = true;

  // ======= INPUT =======
  document.addEventListener('keydown', e => {
    if(mode==='ready'){ startRound(); return; }
    if(mode!=='play' && mode!=='fright') return;
    if(e.key==='ArrowUp')    pac.nextDir = {dx:0,dy:-1};
    if(e.key==='ArrowDown')  pac.nextDir = {dx:0,dy:1};
    if(e.key==='ArrowLeft')  pac.nextDir = {dx:-1,dy:0};
    if(e.key==='ArrowRight') pac.nextDir = {dx:1,dy:0};
  });

  // ======= HELPERS =======
  function isWall(x,y){
    if(y<0||y>=ROWS||x<0||x>=COLS) return true;
    return raw[y][x]===1;
  }
  function isGate(x,y){ return raw[y] && raw[y][x]===5; }
  function centerOf(x,y){ return {cx: x*tile+tile/2, cy: y*tile+tile/2}; }
  function gridAlign(v){ return Math.abs(v-Math.round(v))<0.01; }

  function resetEntities(){
  pac.x=14; pac.y=17; pac.dx=0; pac.dy=0; pac.nextDir=null;
  ghosts=[
    makeGhost("blinky",14,11,"red"),   // above house
    makeGhost("pinky",13,12,"pink"),   // inside
    makeGhost("inky",14,12,"cyan"),    // inside
    makeGhost("clyde",15,12,"orange")  // inside
  ];
}

  function startRound(){
    mode='play';
    overlayText.textContent='';
    modeTimer = performance.now();
    inScatter = true;
  }

  function frighten(){
    ghosts.forEach(g => { if(!g.eyes){ g.edible=true; g.speed = speedFright; }});
    mode='fright';
    setTimeout(()=>{
      ghosts.forEach(g=>{ if(!g.eyes){ g.edible=false; g.speed = speedGhost; }});
      if(mode!=='dying' && mode!=='gameover' && mode!=='levelup') mode='play';
    }, frightDuration);
  }

  function pelletsRemaining(){
    let n=0;
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(raw[y][x]===0||raw[y][x]===3) n++;
    return n;
  }

  // ======= UPDATE =======
  function updatePac(dt){
    // queued turn only when aligned to grid
    if(gridAlign(pac.x) && gridAlign(pac.y) && pac.nextDir){
      const nx = Math.round(pac.x)+pac.nextDir.dx;
      const ny = Math.round(pac.y)+pac.nextDir.dy;
      // gate blocks Pac-Man
      if(!isWall(nx,ny) && !isGate(nx,ny)){
        pac.dx = pac.nextDir.dx;
        pac.dy = pac.nextDir.dy;
        pac.nextDir = null;
      }
    }
    // proposed movement
    let nx = pac.x + pac.dx * pac.speed * (dt);
    let ny = pac.y + pac.dy * pac.speed * (dt);
    // wrap tunnel (left/right)
    if(nx<0) nx = COLS-1; if(nx>COLS-1) nx = 0;
    // block on walls/gate
    if(!isWall(Math.round(nx),Math.round(ny)) && !isGate(Math.round(nx),Math.round(ny))){
      pac.x=nx; pac.y=ny;
    }else{
      pac.dx=0; pac.dy=0;
    }
    // eat pellets
    const gx = Math.round(pac.x), gy = Math.round(pac.y);
    if(raw[gy] && raw[gy][gx]===0){ raw[gy][gx]=2; score+=pelletScore; scoreEl.textContent=score; play(S.waka); }
    else if(raw[gy] && raw[gy][gx]===3){ raw[gy][gx]=2; score+=powerScore; scoreEl.textContent=score; play(S.power); frighten(); }

    // mouth animation
    if(pac.dx!==0||pac.dy!==0){
      if(pac.open){ pac.mouth+=0.05; if(pac.mouth>=0.3) pac.open=false; }
      else{ pac.mouth-=0.05; if(pac.mouth<=0) pac.open=true; }
    }

    // level complete?
    if(pelletsRemaining()===0){
      mode='levelup';
      overlayText.textContent='LEVEL UP!';
      setTimeout(()=>{
        level++;
        // repopulate pellets (keep walls/gate)
        for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
          if(raw[y][x]===2){
            // corners power pellets
            if((y===3&&x===1)||(y===3&&x===COLS-2)||(y===ROWS-4&&x===1)||(y===ROWS-4&&x===COLS-2)) raw[y][x]=3;
            else if(!isGate(x,y) && !isWall(x,y)) raw[y][x]=0;
          }
        }
        resetEntities();
        overlayText.textContent='READY!';
        mode='ready';
      }, 1500);
    }
  }

  function ghostTargets(g){
    if(g.eyes){ // eyes mode: return to house
      return {x:14, y:13};
    }
    if(mode==='fright'){ // random-ish
      const rx = Math.random()<0.5 ? Math.round(g.x)+1 : Math.round(g.x)-1;
      const ry = Math.random()<0.5 ? Math.round(g.y)+1 : Math.round(g.y)-1;
      return {x: Math.max(1,Math.min(COLS-2,rx)), y: Math.max(1,Math.min(ROWS-2,ry))};
    }
    if(inScatter) return g.scatterTarget;
    // chase
    if(g.name==='blinky'){ return {x: Math.round(pac.x), y: Math.round(pac.y)}; }
    if(g.name==='pinky'){  // aim ahead
      return {x: Math.round(pac.x + pac.dx*4), y: Math.round(pac.y + pac.dy*4)};
    }
    if(g.name==='inky'){   // vector from blinky to 2-ahead of pac
      const bl = ghosts.find(x=>x.name==='blinky');
      const tx = Math.round(pac.x + pac.dx*2), ty = Math.round(pac.y + pac.dy*2);
      return {x: tx + (tx - Math.round(bl.x)), y: ty + (ty - Math.round(bl.y))};
    }
    if(g.name==='clyde'){  // if close -> scatter corner, else chase
      const d = Math.hypot(g.x - pac.x, g.y - pac.y);
      if(d<6) return g.scatterTarget; else return {x: Math.round(pac.x), y: Math.round(pac.y)};
    }
    return {x: Math.round(pac.x), y: Math.round(pac.y)};
  }

  function updateGhost(g, dt){
    // choose direction only at intersections (grid aligned)
    if(gridAlign(g.x) && gridAlign(g.y)){
      const gx = Math.round(g.x), gy = Math.round(g.y);
      const dirs = [
        {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}
      ];
      // avoid reversing unless forced
      const reverse = {dx:-g.dx, dy:-g.dy};
      const choices = dirs.filter(d=>{
        const nx=gx+d.dx, ny=gy+d.dy;
        // ghosts can pass gate only when eyes returning
        if(isWall(nx,ny)) return false;
        if(isGate(nx,ny) && !g.eyes) return false;
        // avoid immediate reverse in play/fright
        if(d.dx===reverse.dx && d.dy===reverse.dy && (mode==='play'||mode==='fright')) return false;
        return true;
      });

      // pick best by distance to target
      const t = ghostTargets(g);
      choices.sort((a,b)=>{
        const A = Math.hypot((gx+a.dx)-t.x,(gy+a.dy)-t.y);
        const B = Math.hypot((gx+b.dx)-t.x,(gy+b.dy)-t.y);
        return A-B;
      });
      if(choices.length){
        g.dx = choices[0].dx; g.dy = choices[0].dy;
      }
    }

    // move, with tunnel wrap
    let nx = g.x + g.dx * g.speed * dt;
    let ny = g.y + g.dy * g.speed * dt;
    if(nx<0) nx = COLS-1; if(nx>COLS-1) nx = 0;
    if(!isWall(Math.round(nx),Math.round(ny)) && (!isGate(Math.round(nx),Math.round(ny)) || g.eyes)){
      g.x=nx; g.y=ny;
    }

    // reached house center when eyes -> revive
    if(g.eyes && Math.round(g.x)===14 && Math.round(g.y)===13){
      g.eyes=false; g.edible=false; g.speed=speedGhost; g.dx=0; g.dy=0;
    }
  }

  function handleCollisions(){
    ghosts.forEach(g=>{
      const d = Math.hypot(g.x - pac.x, g.y - pac.y);
      if(d < 0.5){
        if(g.edible && !g.eyes){
          // eat ghost
          score += eatGhostScore;
          scoreEl.textContent = score;
          play(S.eat);
          g.edible=false; g.eyes=true; g.speed = speedGhost*1.2; // faster return
        }else if(!g.eyes){
          // pacman dies
          lives--; livesEl.textContent=lives;
          play(S.death);
          mode='dying';
          overlayText.textContent='OUCH!';
          setTimeout(()=>{
            if(lives<=0){
              if(score>high){ localStorage.pacmanHigh=score; high=score; }
              overlayText.textContent='GAME OVER';
              mode='gameover';
              setTimeout(()=>{ location.reload(); }, 1500);
            }else{
              resetEntities();
              overlayText.textContent='READY!';
              mode='ready';
            }
          }, 1000);
        }
      }
    });
  }

  // ======= DRAW =======
  function drawMaze(){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const v=raw[y][x];
        if(v===1){
          // wall with simple bevel
          ctx.fillStyle = "#0b21ff";
          ctx.fillRect(x*tile,y*tile,tile,tile);
          ctx.fillStyle = "rgba(255,255,255,0.08)";
          ctx.fillRect(x*tile,y*tile,tile,3);
          ctx.fillRect(x*tile,y*tile,3,tile);
        }else if(v===0){
          ctx.fillStyle="#fff";
          ctx.beginPath(); ctx.arc(x*tile+tile/2,y*tile+tile/2,3,0,Math.PI*2); ctx.fill();
        }else if(v===3){
          ctx.fillStyle="#ff0";
          ctx.beginPath(); ctx.arc(x*tile+tile/2,y*tile+tile/2,6,0,Math.PI*2); ctx.fill();
        }else if(v===5){
          // gate
          ctx.fillStyle="#fff";
          ctx.fillRect(x*tile+4,y*tile+tile/2-1,tile-8,2);
        }
      }
    }
  }
  function drawPac(){
    const {cx,cy} = centerOf(pac.x, pac.y);
    const ang = Math.atan2(pac.dy,pac.dx) || 0;
    const m = pac.mouth;
    ctx.fillStyle="yellow";
    ctx.beginPath();
    ctx.arc(cx,cy,tile/2-2, ang+m, ang+2*Math.PI-m);
    ctx.lineTo(cx,cy); ctx.fill();
  }
  function drawGhost(g){
    const {cx,cy} = centerOf(g.x,g.y);
    // body color
    ctx.fillStyle = g.eyes ? "#fff" : (g.edible ? "blue" : g.color);
    ctx.beginPath();
    ctx.arc(cx, cy, tile/2-2, Math.PI, 0);
    ctx.lineTo(cx+tile/2-2, cy+tile/2-2);
    ctx.lineTo(cx-tile/2+2, cy+tile/2-2);
    ctx.closePath();
    ctx.fill();

    // eyes
    ctx.fillStyle = "#fff";
    if(g.eyes){
      ctx.beginPath(); ctx.arc(cx-5,cy,5,0,Math.PI*2);
      ctx.arc(cx+5,cy,5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#000";
      ctx.beginPath(); ctx.arc(cx-5,cy,2,0,Math.PI*2);
      ctx.arc(cx+5,cy,2,0,Math.PI*2); ctx.fill();
    }else{
      const ex = (pac.x - g.x), ey = (pac.y - g.y);
      const len = Math.hypot(ex,ey)||1, ox = (ex/len)*3, oy=(ey/len)*3;
      ctx.beginPath(); ctx.arc(cx-5,cy,5,0,Math.PI*2); ctx.arc(cx+5,cy,5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#000";
      ctx.beginPath(); ctx.arc(cx-5+ox,cy+oy,2,0,Math.PI*2); ctx.arc(cx+5+ox,cy+oy,2,0,Math.PI*2); ctx.fill();
    }
  }

  // ======= MAIN LOOP =======
  let lastTs = performance.now();
  function frame(ts){
    const dt = Math.min(20, ts - lastTs); // clamp
    lastTs = ts;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawMaze();

    if(mode==='ready'){
      // wait for key to start
      overlayText.textContent = 'READY!  (Press any arrow)';
    }else if(mode==='play' || mode==='fright'){
      updatePac(dt);
      // scatter/chase cycling (ignored during fright)
      if(mode==='play'){
        const elapsed = ts - modeTimer;
        if(inScatter && elapsed > scatterDur){ inScatter = false; modeTimer = ts; }
        else if(!inScatter && elapsed > chaseDur){ inScatter = true; modeTimer = ts; }
      }
      ghosts.forEach(g=> updateGhost(g, dt));
      handleCollisions();
    }
    // draw entities
    ghosts.forEach(g=> drawGhost(g));
    drawPac();

    // High score live update
    highEl.textContent = Math.max(high, score);

    requestAnimationFrame(frame);
  }

  // Seed pellets/power pellets where 2's are (outer corners already have power in map)
  // (If you want to force pellets everywhere non-wall non-gate, uncomment next lines)
  // for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++)
  //   if(raw[y][x]===2 && !isGate(x,y)) raw[y][x]=0;

  livesEl.textContent = lives;
  scoreEl.textContent = score;
  overlayText.textContent = 'READY!  (Press any arrow)';
  requestAnimationFrame(frame);
  </script>
</body>
</html>
